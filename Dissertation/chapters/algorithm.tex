\documentclass[dissertation.tex]{subfiles}
\begin{document}
\chapter{Algorithm}
In this chapter we analyze step-by-step the algorithms that implements
the different parts of the program. We do this with the help of the
test scene in \cref{fig:empty}.
\image{scrEmpty.png}{Initial scene.}{fig:empty}

The general idea is to use a B-spline of a certain degree that use as
control polygon a polygonal chain extracted in a graph
derived from a Voronoi diagram method and is clamped to the extremes
of such polygon. In \cref{sec:polChain} we explain in detail how to
build such polygonal chain. Before using the chain as a control
polygon for the B-spline, it is refined and adjusted - as explained in
detail in \cref{sec:obsAvoid} and \cref{sec:degreeInc} - such that is
possible to apply a B-spline with the required degree that don't hit
any obstacle. We implemented a method for an optional adaptive
arrangment of the inner nodes of the B-spline partition described in
\cref{sec:nodeSel} and an optional post processing for the
simplification of the path described in \cref{sec:postPro}.
\section{Polygonal chain}\label{sec:polChain}
In the first phase the objective is to extract a polygonal chain from
the scene, such that the extremes coincides with the start point $s$
and the end point $e$. For doing this we calculate the shortest path
in a graph that is constructed using an adaptation to three
dimensions of a well known bidimensional method (see
\cite{bhattacharya}, \cite{ho-liu} and \cite{seda-pich}) that use
Voronoi diagrams as base.

First we
start distributing points on the faces of the obstacles and on
an invisible bounding box, as in \cref{fig:sites}.
\image{scrSites.png}{Scene with Voronoi sites.}{fig:sites}
The sites are distributes using a recursive method, for each triangle
of the scene\footnote{The scene is composed exclusively of triangles,
  see \cref{cha:scene} for details.} we add three points - one for each
vertex, if not already added before - and then we calculate the area
of the triangle, if the area is bigger than a threshold we decompose
the triangle in four triangles adding three more vertexes on the
midpoints of the edges of the original triangle as in
\cref{fig:triangleDec}, and repeating the process recursively for
each new triangle.
\begin{myfig}{Decomposition of a triangle.}{fig:triangleDec}
  \begin{tikzpicture}[scale=2]
    \coordinate (a1) at (1,0);
    \coordinate (b1) at (2,1);
    \coordinate (c1) at (3,0.3);

    \path[obstacle] (a1) -- (b1) -- (c1) -- (a1);

    \coordinate (dist) at (3.5,0);
    \coordinate (a2) at ($ (a1) + (dist) $);
    \coordinate (b2) at ($ (b1) + (dist) $);
    \coordinate (c2) at ($ (c1) + (dist) $);

    \path[obstacle] (a2) -- (b2) -- (c2) -- (a2);
    \foreach \p in {a1,b1,c1,a2,b2,c2}
    \filldraw[site] (\p) circle (2pt); 

    \coordinate (ab) at ($ (a2)!0.5!(b2) $);
    \coordinate (bc) at ($ (b2)!0.5!(c2) $);
    \coordinate (ac) at ($ (a2)!0.5!(c2) $);

    \path[obstacleTract] (ab) -- (bc) -- (ac) -- (ab);

    \foreach \p in {ab,bc,ac}
    \filldraw[siteHigh] (\p) circle (2pt); 
  \end{tikzpicture}
\end{myfig}

We construct the Voronoi diagram using
those points as input sites, and we build a graph using the vertexes
of the Voronoi cells as graph nodes, and the edges of the cells\footnote{Ignoring the
  infinite edges.} as graph edges. After we prune such graph deleting every edge that
intersect an obstacle face, using the methods explained in \cref{sec:intersections}.
\image{scrGraph.png}{Scene with pruned graph.}{fig:graph}

The result, visible in \cref{fig:graph}, is a graph that embrace the
obstacles like a cobweb where the possible paths on it are roughly
equidistant between the obstacles.

In the bidimensional case the equivalent method implies distributing
the sites in the edges of the polygonal obstacles and then pruning the
graph when an edge of the graph intersect an edge of the obstacle as
in \cref{fig:voronoi2d}.
\image{voronoi2d.png}{Voronoi graph in 2D before pruning (a) and after
  pruning (b).}{fig:voronoi2d}
We decided to extend the method in 3 dimensions distributing points in
the whole faces of obstacles, an alternative would be distributing
points only along the edges of the obstacles.

On the graph obtained from Voronoi we attach the desired start and end
points, and we can obtain a path between the two points using an
algorithm like Dijkstra. Before using that path as a control polygon
we need to take into account the degree of the B-spline and the
position of the obstacles, the details are in \cref{sec:obsAvoid} and
\cref{sec:degreeInc}.

\section{Obstacle avoidance}\label{sec:obsAvoid}
Before using the algorithm explained in \cref{sec:polChain} for
extracting a control polygon for the B-spline, we need to deal with a
problem: every possible path in the graph is
free from collisions by construction - in fact we prune the graph of
every edge that intersect an obstacle - but this don't guarantees that
the curve will be free from obstacles. This concept is expressed in \cref{fig:intersect}.
\begin{myfig}{Schematic of B-spline that intersect an obstacle in the plane.}{fig:intersect}
  \begin{tikzpicture}
    \path[obstacle] (1,0) -- (2,1) -- (3,0) -- (1,0);
    \draw[controlPoly] (0,0) -- (2,2) -- (4,0);
    \draw[spline] (0,0) to [bend left=40] (4,0);

    \filldraw[controlVert] (0,0) circle (2pt);
    \filldraw[controlVert] (2,2) circle (2pt);
    \filldraw[controlVert] (4,0) circle (2pt);
  \end{tikzpicture}
\end{myfig}

In this chapter we make the hypothesis of using
quadratic B-splines\footnote{Degree 2, order 3.}, in
\cref{sec:degreeInc} is explained how is possible to use curves with
higher degree. With this assumption we can exploit the convex hull
property explained in \cref{sec:bsplineProp} and assert that the
resulting curve is contained inside the union of all the triangles
composed of three consecutive control vertexes of the control
polygon. Using that property we can resolve the problem of the
collision maintaining all the triangles in the control polygon free
from collision with the triangles that compose the faces of the
obstacles. Note that the property of convex hull of quadratic
B-splines is valid also in space, so the convex hull is still composed
of planar figures - specifically of triangles - like the faces of the
obstacles. This simplify all the check for the collisions because they
are all between triangles in space and we can use the methods
described in \cref{sec:intersections}.

We designed two different algorithms for dealing with the collision
problem. The first solution described in \cref{sec:inter1} implements
a modified version of Dijkstra's
algorithm that find the shortest path from start to end in the graph
such that all the triangles formed of consecutive points in such path
are free from collisions. The second solution described in
\cref{sec:inter2} use the classical Dijkstra's algorithm for finding
the shortest path from start to end in the graph, checking later for
collisions in the triangles formed of consecutive points in such path
and when one is found some actions are taken for dealing with that.

\subsection{First solution}\label{sec:inter1}
The first solution of the collision problem is to take 
\subsection{Second solution}\label{sec:inter2}
\section{Post processing}\label{sec:postPro}
\section{Degree increase}\label{sec:degreeInc}
\section{Nodes selection}\label{sec:nodeSel}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../dissertation"
%%% End:
